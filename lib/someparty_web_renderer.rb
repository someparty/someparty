# frozen_string_literal: true

require 'middleman-core/renderers/redcarpet'
require 'active_support/core_ext/string/inflections'

# Extends the Redcarpet Markdown parser tack on some useful classes to reign in the media embeds.
# In the past when I was using an atomic CSS framework this was useful for appending the right tags
# to elements generated by Markdown.
class SomePartyWebRenderer < Middleman::Renderers::MiddlemanRedcarpetHTML
  # The lazyload class triggers the lazysizes.js loader to prevent all media
  # from loading on page load. The src in an iframe has to be replaced with
  # data-src for this library to work.

  def block_html(raw_html)
    doc = Nokogiri::HTML(raw_html)
    doc = remove_iframe_src(doc)

    method = find_matching_method(raw_html)
    method ? method.call(doc) : lazyload_iframe_default(doc)
  end

  def remove_iframe_src(doc)
    doc.search('iframe').each do |iframe|
      iframe['data-src'] = iframe['src']
      iframe.remove_attribute('src')
    end
    doc
  end

  def find_matching_method(raw_html)
    iframe_method_mapping.each do |keywords, method|
      return method if keywords.all? { |keyword| raw_html.include? keyword }
    end
    nil
  end

  def iframe_method_mapping
    {
      ['youtube'] => method(:lazyload_youtube),
      ['facebook'] => method(:lazyload_facebook),
      ['vimeo'] => method(:lazyload_vimeo),
      ['twitter-tweet'] => method(:lazyload_twitter),
      ['bandcamp', 'border: 0; width: 100%; height: 120px;'] => method(:lazyload_bandcamp_narrow),
      ['bandcamp'] => method(:lazyload_bandcamp),
      ['cbc', 'data-no-video=1'] => method(:lazyload_cbc),
      ['cbc'] => method(:lazyload_cbc_video),
      ['npr.org'] => method(:lazyload_npr),
      ['soundcloud'] => method(:lazyload_soundcloud)
    }

    # Note Instagram doesn't use an iframe anymore
  end

  def lazyload_iframe_default(doc)
    doc.css('iframe').add_class('lazyload')
    format("<div class='media-wrapper'>%s</div>", doc.to_html)
  end

  def lazyload_soundcloud(doc)
    doc.css('iframe').add_class('lazyload')
    format("<div class='media-wrapper'>%s</div>", doc.to_html)
  end

  def lazyload_youtube(doc)
    doc.css('iframe').add_class('aspect-ratio--object lazyload')
    format("<div class='media-wrapper'><div class='aspect-ratio'>%s</div></div>",
           doc.to_html)
  end

  def lazyload_facebook(doc)
    doc.css('iframe').add_class('aspect-ratio--object lazyload')
    format("<div class='media-wrapper'><div class='aspect-ratio'>%s</div></div>",
           doc.to_html)
  end

  def lazyload_vimeo(doc)
    doc.css('iframe').add_class('aspect-ratio--object lazyload')
    format("<div class='media-wrapper'><div class='aspect-ratio'>%s</div></div>",
           doc.to_html)
  end

  def lazyload_twitter(doc)
    doc.css('iframe').add_class('lazyload')
    format(
      "<div class='media-wrapper'><div class='text-media'>%s</div></div>",
      doc.to_html
    )
  end

  def lazyload_cbc_video(doc)
    doc.css('iframe').add_class('aspect-ratio--object lazyload')
    format("<div class='media-wrapper'><div class='aspect-ratio'>%s</div></div>",
           doc.to_html)
  end

  def lazyload_cbc(doc)
    doc.css('iframe').add_class('lazyload')
    format("<div class='media-wrapper'><div class='text-media'>%s</div></div>", doc.to_html)
  end

  def lazyload_bandcamp(doc)
    doc.css('iframe').add_class('lazyload')
    format("<div class='media-wrapper'>%s</div>", doc.to_html)
  end

  def lazyload_bandcamp_narrow(doc)
    doc.css('iframe').add_class('lazyload')
    # Bandcamp's narrow player doesn't center nicely with the provided inline styles
    doc.at_css('iframe').set_attribute('style', 'border: 0; width: 700px; max-width: 100%; height: 120px;')
    format("<div class='media-wrapper'>%s</div>", doc.to_html)
  end

  def lazyload_npr(doc)
    doc.css('iframe').add_class('aspect-ratio--object lazyload')
    format("<div class='media-wrapper'><div class='aspect-ratio'>%s</div></div>",
           doc.to_html)
  end

  def block_quote(text)
    format('<blockquote>%s</blockquote>', text)
  end

  def header_generic(text, header_level)
    format('<h%s class="generic">%s</span></h%s>', header_level,
           text, header_level)
  end

  def header(text, header_level)
    return header_generic(text, header_level) if header_level != 3

    artist_title = nil
    media_title = nil

    doc = Nokogiri::HTML(text)
    header_link = doc.css('a')

    if header_link.size.positive?
      # Use the first link in the header, usually the band name, as the anchor ID
      anchor = header_link.first.content
      artist_title = header_link
      # media_title = text.sub(header_link.first.to_s, '')
      split_text = text.split('</a>')
      split_text.shift
      media_title = split_text.join
    else
      # No link in the header. Split on the : if it's thre
      split_text = text.split(':')
      anchor = if split_text.size.positive?
                 split_text[0]
               else
                 # Just use the text
                 text
               end

      if split_text.size.positive?
        artist_title = split_text[0]
        media_title = text.sub(split_text[0], '')
      end
    end
    # Remove the leading colon, this is kept for the email that doesn't have the same styling.
    media_title = media_title.sub(/^: /, '') if media_title

    anchor_id = anchor.parameterize(separator: '_')

    format('<h%s id="%s"><span class="artist-title">%s</span><span class="media-title">%s</span></h%s>', header_level,
           anchor_id, artist_title, media_title, header_level)
  end

  def hrule
    '<hr/>'
  end

  def link(link, title, content)
    # Below embedded media I want to insert a simple link
    # to the source, which we'll use primarily in the emails
    # but don't want to take up too much space on the web
    # This type of link we'll detect in the markdown if it has
    # a title that starts with "#", which is a little kludgy but
    # doesn't break the source Markdown

    css_class = ''

    if title && title.start_with?('#')
      css_class = 'black no-underline fw4 db tc f6 nt3 mb4'
      if title.length > 1
        title[0] = ''
      else
        title = nil
      end
    end

    if @local_options[:no_links]
      link_string = link.dup
      link_string << %("#{title}") if title.present? && title != alt_text
      "[#{content}](#{link_string})"
    else
      attributes = { title:, class: css_class }
      attributes[:target] = external_link?(link) ? '_blank' : '_self'
      attributes.merge!(@local_options[:link_attributes]) if @local_options[:link_attributes]
      scope.link_to(content, link, attributes)
    end
  end

  def external_link?(link)
    link.start_with?('http://', 'https://')
  end

  def list(content, list_type)
    case list_type
    when :ordered
      format('<ol>%s</ol>', content)
    when :unordered
      format('<ul>%s</ul>', content)
    end
  end

  def paragraph(text)
    if text.include? '<img'
      format("<p class='image'>%s</p>", text)
    elsif text.include? '<small'
      if text.include? 'https://www.someparty.ca/contests'
        format("<p class='contest'>%s</p>", text)
      else
        format("<p class='media-links' data-controller='share'>%s</p>", text)
      end
    else
      format('<p>%s</p>', text)
    end
  end

  def highlight(text)
    # I'm hijacking highlight to use it to render the media links header line below H3s
    # Note this fires before paragraph, so the <small> will be wrapped in a paragraph with no top margin
    # as per the paragraph(text) function
    format("<small>%s <span data-share-target='container'></span></small>", text)
  end
end
